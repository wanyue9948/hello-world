'''
解题思路
看到这题就想着通过双“指针”，其实不是指针，只是标识位置的两个int型变量，让列表中存储的二进制序列从头(高位)往后(低位)依次扫描，遇到二进制 '1',
则给i赋值为j,给j赋值为k，意思是一个指针j指向后面相邻的' 1' ,一个指针i指向当前的'1',还有一个k用于列表的遍历，记录当前位置下标。
因为初始化时i,j,k都是0，遇到1之后，会让i=j,j=k,通过k不停的往后走，i会接替它的相邻的1即j的位置，而j也变为了新的1的位置k,
这样就保证了i,j永远指向的是相邻的两个1，把j-i的值存入ans列表中，待循环结束，返回ans的最大值即可。

注：

1:可以把一个数的二进制形式放入一个列表中，这样会把二进制的01作为字符‘0’‘1’存入一个列表，而且会把‘0b’表示二进制的格式也存入，
所以需要对这个列表进行截断前两个位置的处理。

2:因为一个数的二进制表示，它的最高位一定是1，因为不会有多余的用不到的0放在高位，所以这个思路就可以通过，如果高位还有冗余的0，
比如输入0100==4的二进制，这个思路就不满足题意了。好在二进制表示4时-->4==0b100
'''
def binaryGap(n):
        ls=list(bin(n))
        ls=ls[2::]
        ans=[0]
        size=len(ls)
        i,j,k=0,0,0
        while k<size:
            if ls[k]>'0':
                i=j
                j=k
                ans.append(j-i-1)
            k+=1
        return max(ans)
print(binaryGap(1041))